<HTML>

<!-- Mirrored from cse.csusb.edu/kay/cs460/phase2.html by HTTrack Website Copier/3.x [XR&CO'2010], Tue, 18 Jun 2013 23:10:59 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head> <title>CSE 460 Project - Phase II</title> </head>
<BODY >

<H2>Project - Phase II: Process Management</H2>
<H3>
CSE 460: Operating Systems
<br>
Spring 2013, Zemoudeh
<br>
School of Computer Science and Engineering
<br>
California State University, San Bernardino
</H3>

<br>

<P>
In this phase we will add
the process management layer to our OS,
converting the single-user OS of phase I to
a time-sharing OS in phase II.
Under your home directory create a <code>cs460</code> directory, under that directory create directories
 <code>phase1</code>
 and <code>phase2</code>.
Copy all your code and data from phase I to both <code>phase1</code>
 and <code>phase2</code>.
Modify, implement, and run the new version of the OS
in <code>phase2</code> directory without changing your old code from phase I.

<P>
In this phase every program consists of 5 files with
the same name but different suffixes: <code>.s, .o, .in, .out,</code> and <code>.st.</code> For example, the factorial
program consists of <code>fact.s, fact.o, fact.in, fact.out,</code> and <code>fact.st.</code> The <code>.s</code> and <code>.in</code>
files must exist before starting the OS. They hold the assembly
program and its input
respectively.
<code>.o</code> file has to be generated by the OS for each <code>.s</code> file
through a call to the assembler.
<code>.out</code> file is created by the OS and contains the output of the
program. <code>.st</code> file is an input/output file and contains the stack when the
process is not running;
only one stack (of the running program) at a time resides in memory.
When VM is allocated to a process, its stack is read into
high memory from its <code>.st</code> file; and when a process relinquishes VM,
its stack
is written onto its <code>.st</code> file.
By examining the value of <code>sp</code> register, the OS can tell whether
<code>.st</code> file has to be saved.
When a process relinquishes VM and <code>sp = 256</code> in the VM, there is no stack and therefore there is nothing to save.
Otherwise, when <code>sp < 256</code>, there is a stack and its content must be saved for future restart.
Analogously, when a process is assigned to the VM, if <code>sp</code> in its PCB is less than 256 then it has
a stack and it needs to be loaded from its <code>.st</code> into memory. 
Remove this file when its corresponding process halts.

<P>
When the OS comes up it looks in the
current directory and gathers all <code>.s</code> files:

<pre>
     system("ls *.s &gt; progs");
</pre>

It then opens <code>progs</code> and reads the file names.
Each file is  assembled, its object code loaded
in memory, and a pointer to its PCB is stored in a linked-list:

<PRE>
     list&lt;PCB *&gt; jobs;
     PCB * p = new PCB;
     jobs.push_back(p);
</PRE>

In this phase of the project the degree of multiprogramming is the same as the
number of <code>.s</code> files in the current directory (in <code>progs</code>).
The processes are resident in memory
until the OS halts. The processes (PCBs) are either in the ready, waiting,
or running state. Maintain two queues of processes, Ready Queue and Wait Queue.

The queues are of type pointer to PCB:

<pre>
     queue&lt;PCB *&gt; readyQ, waitQ;
</pre>

The running process is also represented by a pointer to PCB:

<pre>
     PCB * running;
</pre>

Pointers in <code>readyQ, waitQ,</code> and <code>running</code> point to a PCB in
the linked-list of PCBs (<code>jobs</code>).
Initially all processes are pushed on the <code>readyQ</code>.
When a process is assigned to the VM and it starts running, it either
completes its time slice, when it will be added to the end of <code>readyQ</code>;
or it executes an I/O operation (<code>read</code> or <code>write</code> instruction),
when it will be added to the end of <code>waitQ</code>. A number of other conditions may also cause the VM to return.
Therefore, the VM returns to the OS with a return status. The complete list of return statuses follows:
<br>
<br>
a. overflow
<br>
b. time slice
<br>
c. <code>halt</code> instruction
<br>
d. out-of-bound reference
<br>
e. stack overflow
<br>
f. stack underflow
<br>
g. invalid opcode
<br>
h. I/O operation
<br>
<br>
The VM sets the status register based on the above conditions and the OS examines it to know how the previous process
relinquished VM. As a result, in this phase, <code>sr</code> is modified to include VM Return-status encoded in 3 bits:

<P>

<style type="text/css">
table.sample1 {
	border-width: 0px;
	border-spacing: ;
	border-style: outset;
	border-color: gray;
	border-collapse: collapse;
	background-color: white;
}
table.sample1 th {
	border-width: 1px;
	padding: 1px;
	border-style: inset;
	border-color: gray;
	background-color: white;
	-moz-border-radius: ;
}
table.sample1 td {
	border-width: 0px;
	padding: 5px;
	border-style: inset;
	border-color: gray;
	background-color: white;
	-moz-border-radius: ;
}
</style>
<table class="sample1">
<tr>
<th> &nbsp; d &nbsp; </th>
<th> &nbsp; ... &nbsp; </th>
<th> &nbsp; d &nbsp; </th>
<th> &nbsp; I/O Register &nbsp; </th>
<th> &nbsp; VM Return-status &nbsp; </th>
<th> &nbsp; V &nbsp; </th>
<th> &nbsp; L &nbsp; </th>
<th> &nbsp; E &nbsp; </th>
<th> &nbsp; G &nbsp; </th>
<th> &nbsp; C &nbsp; </th>
</tr>
<tr>
<td> &nbsp; 15  </td>
<td> &nbsp; </td>
<td> &nbsp; 10  </td>
<td> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 9:8  </td>
<td> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 7:5  </td>
<td> &nbsp; 4  </td>
<td> &nbsp; 3  </td>
<td> &nbsp; 2  </td>
<td> &nbsp; 1  </td>
<td> &nbsp; 0  </td>
</tr>
</table>

These three bits in <code>sr</code> are treated as follows:
<br>
<table>
<tr> <td> <strong> VM Return-status <td> <strong> &nbsp; Meaning
<tr> <td> 000 <td> &nbsp; Time slice
<tr> <td> 001 <td> &nbsp; Halt Instruction
<tr> <td> 010 <td> &nbsp; Out-of-bound Reference
<tr> <td> 011 <td> &nbsp; Stack Overflow
<tr> <td> 100 <td> &nbsp; Stack Underflow
<tr> <td> 101 <td> &nbsp; Invalid Opcode
<tr> <td> 110 <td> &nbsp; Read Operation
<tr> <td> 111 <td> &nbsp; Write Operation
</table>

<P>
In case of Read/Write (I/O) operations, the register involved is specified in bits 8 and 9.

<P>
Any time the VM returns (one of the above eight conditions occurs or overflow bit is set) a context switch
takes place and the scheduler reorganizes the queues.
Context switch takes 5 clock ticks (all CPU time). During this time
<br>
<B>first,</B> all the processes
in <code>waitQ</code> whose I/O operation has been completed
are placed in <code>readyQ</code>,
<br>
<B>second</B> the running process is placed in the proper queue or terminated,
and 
<br>
<B>third</B> the next
process from <code>readyQ</code> is assigned to VM (CPU).

<P>
I/O requests could immediately occur in the PCB: when an I/O operations is encountered,
immediately perform the I/O (<code>read</code> or <code>write</code> instruction)
in the PCB, move the PCB to <code>waitQ</code>, and set the interrupt
(I/O completion) time to <code>clock + 28</code>. During the next
context switch, if the I/O completion time of a process in <code>waitQ</code> is less than or equal to the current time
(the I/O interrupt has arrived),
its PCB is moved to the <code>readyQ</code>.
If all processes are waiting on I/O (<code>readyQ</code> is empty),
you must add as many clock ticks to the clock 
to match the completion time of the earliest I/O request, at which point
that process will be ready for execution and is moved to <code>readyQ</code> and then to running state.
This is counted as idle time and decreases CPU utilization, see below.

<p>
If the time slice of a process is over in the middle of <code>load</code>,
<code>store</code>,
<code>call</code>, and
<code>return</code> instructions,
finish the instruction first and then perform the context switch.
Any time this occurs,
effectively the time slice of the process is extended by at
most 3 clock ticks.

<P>
All memory references made by a process have to be
checked against its <code>base</code> and <code>limit</code> values. If an out-of-bound reference
is made, the program is terminated and an appropriate message must appear in the <code>.out</code> file.
Note all addresses have to be an offset from <code>base</code>;
at run time add the <code>base</code> to the addresses for
<code>load</code>,
<code>store</code>,
<code>call</code>,
and the <code>jump</code> instructions.

<P>
Each PCB should at least include <code>pc</code>, <code>r[0]-r[3]</code>, <code>sr</code>,
<code>sp</code>, <code>base</code>, <code>limit</code>, process name, 
<code>fstream</code>s associated with the <code>.o</code>, <code>.in</code>, <code>.out</code>,
and <code>.st</code> files, and the following 
accounting information: VM (CPU) Time, Waiting Time, Turnaround Time,
I/O Time, and the Largest Stack Size.
The accounting information for each process must appear
at the end of the <code>.out</code> file.
Also VM Utilization and Throughput must appear
at the end of EACH <code>.out</code> file after the process
specific accounting information.

<P>
The definitions of the accounting information as they pertain to 
this phase are:

<P>
Process Specific:

<br>
CPU Time: number of clock ticks the process executes in CPU.
(<code>read</code> and <code>write</code> each take 1 CPU clock tick and 27 I/O clock ticks.)

<br>
Waiting Time: number of clock ticks spent in <code>readyQ</code>.

<br>
Turnaround Time: time up to and including the <code>halt</code> instruction execution.

<br>
I/O Time: number of clock ticks spent in <code>waitQ</code>.

<br>
Largest Stack Size: largest number of memory locations allocated to the stack.

<P>
System Information:

<br>
System Time = sum of all Context Switch Times and Idle Times

<br>
System CPU Utilization: percent of the time CPU is busy = (final clock - sum of all Idle Times) / final clock

<br>
User CPU Utilization: percent of the time CPU executes user jobs = (sum of all jobs' CPU time) / final clock

<br>
Throughput: number of processes completed per second. Assume 1 second = 10000 clock ticks.

<P>
All times are summarized in the following table:

<P>
<style type="text/css">
table.sample {
	border-width: 1px;
	border-spacing: ;
	border-style: outset;
	border-color: gray;
	border-collapse: collapse;
	background-color: white;
}
table.sample th {
	border-width: 1px;
	padding: 5px;
	border-style: inset;
	border-color: gray;
	background-color: white;
	-moz-border-radius: ;
}
table.sample td {
	border-width: 1px;
	padding: 5px;
	border-style: inset;
	border-color: gray;
	background-color: white;
	-moz-border-radius: ;
}
</style>

<table class="sample">
<tr> <th> load/store instr <th> call/return instr <th> read/write instr <th> all other instr <th> time slice     <th> context switch <th> 1 second </tr>
<tr> <td> 4 clock ticks    <td> 4 clock ticks     <td> 28 clock ticks   <td> 1 clock tick    <td> 15 clock ticks <td> 5 clock ticks <td> 10000 ticks </tr>
</table>

<P>
Your <code>OS</code> class could be a <code>friend</code> of the <code>VirtualMachine</code> class
so that for each process the state of the VM
can be loaded from or stored to its PCB by the OS.

<P>
Run your OS for 6 programs as follows:

<br>
(From phase I) <code>fact1.s</code> with input 6 (<code>fact1.in</code> contains 6)

<br>
(From phase I) <code>fact2.s</code> with input 8 (<code>fact2.in</code> contains 8)

<br>
(From phase I) <code>sub.s</code> the subtract 2 program 

<br>
<code>sum1.s</code> with input 50 (<code>sum1.in</code> contains 50)

<br>
<code>sum2.s</code> with input 101 (<code>sum2.in</code> contains 101)

<br>
<code>io.s</code> where <code>io.in</code> contains 0 1 2 3 4 5 6 7 8 9 10 11

<P>
The <code>sum</code> program is as follows:

<PRE>
    loadi  0 1   ! i = 1
    loadi  1 0   ! sum = 0
    read   2
    compr  0 2
    jumpe  8     ! done
    add    1 0   ! sum += i
    addi   0 1   ! i++
    jump   3     ! loop again
    write  1
    halt
</PRE>

The <code>io.s</code> program is as follows:

<PRE>
    loadi  0 0   ! i = 0
    compri 0 6   ! 6 pairs to read
    jumpe  9     ! i == 6 done
    read   1
    read   2
    add    1 2
    write  1
    addi   0 1   ! i++
    jump   1     ! loop again
    halt
</PRE>

Implement your program incrementally. 
<br>
First, modify your OS to
run only two programs without
any I/O (just compute intensive <code>.s</code> programs).
<br>
Second, modify your OS to handle programs with I/O.
<br>
Third, try several compute
and I/O intensive programs.
<br>
Fourth, modify your OS to gather accounting information.
<br>
Fifth, modify your OS to handle programs with subroutine calls (which grow
stack).

<P>
Demonstrate your program and
hand in printouts of your source code
including the OS, the new VM, and the assembler, and all <code>.s</code>,
<code>.o</code>, <code>.in</code>, and <code>.out</code> files.
The same grading criteria as phase I holds.
</BODY>

<!-- Mirrored from cse.csusb.edu/kay/cs460/phase2.html by HTTrack Website Copier/3.x [XR&CO'2010], Tue, 18 Jun 2013 23:10:59 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</HTML>
